import * as vscode from 'vscode';
import * as fs from 'fs/promises';
import * as path from 'path';
import { glob } from 'glob';
import { ProjectStructureConfig } from './config';
import { formatBytes, getFileExtension, getLanguage } from './utils';

interface FileInfo {
    name: string;
    path: string;
    type: 'file' | 'directory';
    size?: number;
    modified?: Date;
    extension?: string;
    language?: string;
    content?: string;
    children?: FileInfo[];
}

export async function generateProjectStructure(
    rootPath: string,
    config: ProjectStructureConfig,
    progress?: vscode.Progress<{ message?: string; increment?: number }>
): Promise<string> {
    progress?.report({ message: 'Scanning files...' });

    const fileTree = await buildFileTree(rootPath, config);

    progress?.report({ message: 'Generating output...' });

    let output: string;
    let extension: string;

    switch (config.outputFormat) {
        case 'json':
            output = generateJsonOutput(fileTree, rootPath);
            extension = 'json';
            break;
        case 'markdown':
            output = generateMarkdownOutput(fileTree, rootPath, config);
            extension = 'md';
            break;
        case 'txt':
            output = generateTextOutput(fileTree, rootPath);
            extension = 'txt';
            break;
    }

    const outputPath = path.join(rootPath, `${config.outputFileName}.${extension}`);
    await fs.writeFile(outputPath, output, 'utf-8');

    return outputPath;
}

async function buildFileTree(
    rootPath: string,
    config: ProjectStructureConfig
): Promise<FileInfo> {
    const root: FileInfo = {
        name: path.basename(rootPath),
        path: rootPath,
        type: 'directory',
        children: []
    };

    const files = await glob('**/*', {
        cwd: rootPath,
        ignore: config.excludePatterns,
        dot: true,
        nodir: false
    });

    for (const file of files) {
        const fullPath = path.join(rootPath, file);
        const stats = await fs.stat(fullPath);

        const fileInfo: FileInfo = {
            name: path.basename(file),
            path: file,
            type: stats.isDirectory() ? 'directory' : 'file'
        };

        if (fileInfo.type === 'file') {
            if (config.includeFileStats) {
                fileInfo.size = stats.size;
                fileInfo.modified = stats.mtime;
            }

            fileInfo.extension = getFileExtension(file);
            fileInfo.language = getLanguage(file);

            if (config.includeFileContent && stats.size <= config.maxFileSize) {
                try {
                    fileInfo.content = await fs.readFile(fullPath, 'utf-8');
                } catch (error) {
                    fileInfo.content = '[Binary or unreadable file]';
                }
            }
        }

        addToTree(root, file.split(path.sep), fileInfo);
    }

    return root;
}

function addToTree(root: FileInfo, pathParts: string[], fileInfo: FileInfo) {
    if (pathParts.length === 1) {
        root.children = root.children || [];
        root.children.push(fileInfo);
        return;
    }

    const [current, ...rest] = pathParts;
    let child = root.children?.find((c) => c.name === current);

    if (!child) {
        child = {
            name: current,
            path: pathParts.slice(0, pathParts.length - rest.length).join(path.sep),
            type: 'directory',
            children: []
        };
        root.children = root.children || [];
        root.children.push(child);
    }

    addToTree(child, rest, fileInfo);
}

function generateJsonOutput(fileTree: FileInfo, rootPath: string): string {
    return JSON.stringify(
        {
            generatedAt: new Date().toISOString(),
            rootPath: rootPath,
            tree: fileTree
        },
        null,
        2
    );
}

function generateMarkdownOutput(
    fileTree: FileInfo,
    rootPath: string,
    config: ProjectStructureConfig
): string {
    const stats = calculateStats(fileTree);
    
    let output = `# ðŸ—ï¸ Project Structure: ${fileTree.name}\n\n`;
    output += `> **Generated by [Project Structure Generator for AI](https://marketplace.visualstudio.com/items?itemName=Azizkh07.project-structure-generator-ai)**\n\n`;
    output += `ðŸ“… **Generated:** ${new Date().toLocaleString()}\n`;
    output += `ðŸ“ **Root Path:** \`${rootPath}\`\n`;
    output += `ðŸ“Š **Total Size:** ${formatBytes(stats.totalSize)} | `;
    output += `ðŸ“„ **Files:** ${stats.files} | `;
    output += `ðŸ“‚ **Directories:** ${stats.directories}\n\n`;
    
    output += `---\n\n`;
    output += `## ðŸŒ³ File Tree\n\n`;
    output += '```\n';
    output += generateTreeView(fileTree, '', true);
    output += '```\n\n';

    if (config.includeFileContent) {
        output += `---\n\n## ðŸ“ File Contents\n\n`;
        output += `> **Note:** Only files under ${config.maxFileSize / 1024}KB are included to keep the output manageable.\n\n`;
        output += generateFileContents(fileTree);
    }

    output += `---\n\n## ðŸ“Š Project Statistics\n\n`;
    output += `| Metric | Value |\n`;
    output += `|--------|-------|\n`;
    output += `| ðŸ“„ Total Files | ${stats.files} |\n`;
    output += `| ðŸ“‚ Total Directories | ${stats.directories} |\n`;
    output += `| ðŸ’¾ Total Size | ${formatBytes(stats.totalSize)} |\n`;
    output += `| ðŸ·ï¸ Languages | ${stats.languages.length > 0 ? stats.languages.join(', ') : 'None detected'} |\n\n`;

    if (stats.languages.length > 0) {
        output += `### ðŸŽ¨ Language Breakdown\n\n`;
        const languageStats = calculateLanguageStats(fileTree);
        for (const [language, count] of Object.entries(languageStats)) {
            output += `- **${language}:** ${count} file${count > 1 ? 's' : ''}\n`;
        }
        output += `\n`;
    }

    output += `---\n\n`;
    output += `## ðŸ¤– AI Assistant Usage\n\n`;
    output += `This project structure was generated to help AI assistants understand your codebase. `;
    output += `You can copy and paste this entire structure into ChatGPT, Claude, or other AI tools `;
    output += `to provide context about your project.\n\n`;
    output += `**Tip:** When asking for help with your code, include this structure to give the AI `;
    output += `a complete overview of your project organization.\n\n`;

    return output;
}

function generateTreeView(node: FileInfo, prefix: string, isLast: boolean): string {
    let output = '';
    const connector = isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';
    const icon = node.type === 'directory' ? 'ðŸ“' : 'ðŸ“„';

    output += `${prefix}${connector}${icon} ${node.name}`;

    if (node.type === 'file' && node.size !== undefined) {
        output += ` (${formatBytes(node.size)})`;
    }

    output += '\n';

    if (node.children && node.children.length > 0) {
        const newPrefix = prefix + (isLast ? '    ' : 'â”‚   ');
        node.children.forEach((child, index) => {
            output += generateTreeView(child, newPrefix, index === node.children!.length - 1);
        });
    }

    return output;
}

function generateFileContents(node: FileInfo, level: number = 3): string {
    let output = '';

    if (node.type === 'file' && node.content) {
        output += `${'#'.repeat(level)} ${node.path}\n\n`;
        output += `**Language:** ${node.language || 'Unknown'}\n\n`;
        output += '```' + (node.language || '') + '\n';
        output += node.content;
        output += '\n```\n\n';
    }

    if (node.children) {
        for (const child of node.children) {
            output += generateFileContents(child, level + 1);
        }
    }

    return output;
}

function generateTextOutput(fileTree: FileInfo, rootPath: string): string {
    let output = `PROJECT STRUCTURE: ${fileTree.name}\n`;
    output += `Generated: ${new Date().toLocaleString()}\n`;
    output += `Root Path: ${rootPath}\n`;
    output += `\n${'='.repeat(80)}\n\n`;
    output += generateTreeView(fileTree, '', true);
    return output;
}

function calculateStats(node: FileInfo): {
    files: number;
    directories: number;
    totalSize: number;
    languages: string[];
} {
    let stats = {
        files: 0,
        directories: 0,
        totalSize: 0,
        languages: new Set<string>()
    };

    if (node.type === 'file') {
        stats.files = 1;
        stats.totalSize = node.size || 0;
        if (node.language) {
            stats.languages.add(node.language);
        }
    } else {
        stats.directories = 1;
    }

    if (node.children) {
        for (const child of node.children) {
            const childStats = calculateStats(child);
            stats.files += childStats.files;
            stats.directories += childStats.directories;
            stats.totalSize += childStats.totalSize;
            childStats.languages.forEach((lang) => stats.languages.add(lang));
        }
    }

    return {
        ...stats,
        languages: Array.from(stats.languages)
    };
}

function calculateLanguageStats(node: FileInfo): Record<string, number> {
    let languageCount: Record<string, number> = {};

    if (node.type === 'file' && node.language) {
        languageCount[node.language] = (languageCount[node.language] || 0) + 1;
    }

    if (node.children) {
        for (const child of node.children) {
            const childStats = calculateLanguageStats(child);
            for (const [language, count] of Object.entries(childStats)) {
                languageCount[language] = (languageCount[language] || 0) + count;
            }
        }
    }

    return languageCount;
}